<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="description" content="R√©solveur d'√©quations du premier degr√© avec support des parenth√®ses." />
  <meta name="color-scheme" content="light dark" />
  <title>√âquation Pro | R√©solveur du Premier Degr√©</title>
  <style>
    :root {
      --radius: 14px;
      --shadow: 0 10px 28px rgba(0,0,0,.18);
      --primary: #1976d2; 
      --primary-dark: #1565c0;
      --transition: all 0.2s ease;
      --focus-glow: 0 0 0 3px rgba(25, 118, 210, 0.3);
      --comment-color: #9aa2af;
      --op-color: #ef5350;
    }
    body.theme-dark {
      --bg: #0f1115; --card: #161a22; --text: #e8ecf1; --muted: #9aa2af;
      --border: #232939; --input-bg: #0d1117; --placeholder: #5c6370;
      --accent: rgba(25, 118, 210, 0.15);
    }
    body.theme-light {
      --bg: #f6f8fc; --card: #ffffff; --text: #10141a; --muted: #586171;
      --border: #e5e9f1; --input-bg: #fefefe; --placeholder: #8a94a6;
      --accent: rgba(25, 118, 210, 0.08); --comment-color: #586171;
    }
    body {
      margin: 0; background: var(--bg); color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.5; transition: var(--transition);
    }
    h1, h2, h3 { font-weight: 600; margin: 0; }

    .topbar {
      position: sticky; top: 0; z-index: 3; background: var(--card);
      border-bottom: 1px solid var(--border); padding: 12px 16px;
      display: flex; align-items: center; justify-content: space-between;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    .icon-btn, .btn {
      border: 1px solid var(--border); background: transparent; color: var(--text);
      border-radius: 10px; font-weight: 500; touch-action: manipulation;
      transition: var(--transition); cursor: pointer;
    }
    .icon-btn { padding: 8px 10px; font-size: 16px; display: inline-flex; align-items: center; justify-content: center; }
    .btn { padding: 10px 16px; font-size: 14px; }
    .btn:hover, .icon-btn:hover { background: var(--accent); border-color: rgba(25, 118, 210, 0.24); }
    .btn.primary { background: var(--primary); color: #fff; border-color: var(--primary); }
    .btn[disabled] { opacity: 0.5; cursor: not-allowed; background: var(--accent); border-color: transparent; }

    .container { max-width: 900px; margin: 0 auto; padding: 16px; }
    .card {
      background: var(--card); border: 1px solid var(--border);
      border-radius: var(--radius); box-shadow: var(--shadow);
      padding: 16px; margin: 16px 0; animation: fadeIn 0.3s ease-out;
    }
    .card h2 { font-size: 18px; margin-bottom: 12px; }

    input[type="text"] {
      background: var(--input-bg); color: var(--text); border: 1px solid var(--border);
      border-radius: 8px; padding: 10px 12px; font-size: 16px; transition: var(--transition);
      text-align: center;
    }
    input:focus { outline: none; border-color: var(--primary); box-shadow: var(--focus-glow); }
    
    /* Styles originaux pour les 4 cases */
    .coeff-input { width: 60px; }

    .equation-container {
        display: flex; align-items: center; justify-content: center;
        gap: 10px; flex-wrap: wrap; font-size: 20px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
    }
    .equation-side { display: flex; align-items: center; gap: 10px; }
    
    /* --- NOUVEAU : Styles pour le mode texte libre --- */
    .mode-selector {
      display: flex; justify-content: center; gap: 8px; margin-bottom: 20px;
    }
    .mode-btn { opacity: 0.6; }
    .mode-btn.active { opacity: 1; border-color: var(--primary); background: var(--accent); color: var(--primary); }
    
    #inputFullEq {
      width: 100%; max-width: 500px; font-size: 20px; padding: 12px;
    }
    /* ------------------------------------------------ */

    #liveEquation {
        font-size: 22px; text-align: center; color: var(--primary); font-weight: 500;
        padding: 12px; background: var(--accent); border-radius: 10px; margin-top: 20px;
        word-break: break-all;
        min-height: 1.5em;
    }

    pre {
      white-space: pre-wrap; margin: 0; background: var(--input-bg);
      border: 1px solid var(--border); border-radius: 10px; padding: 14px;
      font: 16px/1.8 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
    }
    .comment { color: var(--comment-color); }
    .op-highlight { color: var(--op-color); }
    .step-header { font-weight: bold; color: var(--primary); margin-top: 10px; display:block; }
    .msg { margin-top: 12px; font-size: 13px; }
    .msg.error { color: #ff6b6b; } .msg.success { color: #4caf50; }

    dialog {
      border: 1px solid var(--border); background: var(--card); color: var(--text);
      border-radius: var(--radius); padding: 16px; max-width: 720px; 
      width: calc(100% - 32px); box-shadow: var(--shadow);
    }
    dialog::backdrop { background: rgba(0,0,0,0.4); }
    .dialog-actions { margin-top: 12px; display: flex; justify-content: flex-end; gap: 8px; }

    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes dialog-show { from { opacity: 0; transform: scale(0.97) translateY(10px); } to { opacity: 1; transform: scale(1) translateY(0); } }
    dialog[open] { animation: dialog-show 0.3s ease-out forwards; }
    
    /* Dropdown CSS (inchang√©) */
    .dropdown { position: relative; }
    .dropdown-summary { display: flex; align-items: center; gap: 8px; font-size: 18px; font-weight: 600; cursor: pointer; list-style: none; padding: 4px 8px; border-radius: 8px; transition: var(--transition); }
    .dropdown-summary:hover { background: var(--accent); }
    .dropdown-summary::-webkit-details-marker { display: none; }
    .dropdown-summary .arrow { transition: transform 0.2s ease; }
    details[open] > .dropdown-summary .arrow { transform: rotate(180deg); }
    .dropdown-menu { position: absolute; top: calc(100% + 8px); left: 0; z-index: 10; background: var(--card); border: 1px solid var(--border); border-radius: var(--radius); box-shadow: var(--shadow); width: 280px; padding: 8px; opacity: 0; transform: translateY(-10px); pointer-events: none; transition: opacity 0.2s ease, transform 0.2s ease; }
    details[open] > .dropdown-menu { opacity: 1; transform: translateY(0); pointer-events: auto; }
    .dropdown-menu a { display: flex; align-items: center; gap: 12px; padding: 10px 12px; border-radius: 8px; text-decoration: none; color: var(--text); font-size: 14px; font-weight: 500; }
    .dropdown-menu a:hover { background: var(--accent); }
    .dropdown-menu a.active { font-weight: 600; color: var(--primary); background: var(--accent); }
    .dropdown-menu .emoji { font-size: 18px; }
    .dropdown-menu hr { border: none; border-top: 1px solid var(--border); margin: 8px 0; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body class="theme-dark">
  <header class="topbar">
    <details class="dropdown">
      <summary class="dropdown-summary">
        <span class="emoji">‚öñÔ∏è</span>
        <span>√âquation Pro</span>
        <svg class="arrow" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M7 10l5 5 5-5H7z"></path></svg>
      </summary>
      <nav class="dropdown-menu">
        <a href="index.html"><span class="emoji">üî¢</span><span>Menu Principal</span></a>
        <hr>
        <a href="Pythagore_pro.html"><span class="emoji">üßÆ</span><span>Pythagore Pro</span></a>
        <a href="Thales_Pro.html"><span class="emoji">üìê</span><span>Thal√®s Pro</span></a>
        <a href="Developpement_Pro.html"><span class="emoji">‚öôÔ∏è</span><span>D√©veloppement Pro</span></a>
        <a href="Factorisation_Pro.html"><span class="emoji">üß©</span><span>Factorisation Pro</span></a>
        <a href="Equation_Premier_Degre_Pro.html" class="active"><span class="emoji">‚öñÔ∏è</span><span>√âquation Pro (1er degr√©)</span></a>
        <a href="Statistique_Pro.html"><span class="emoji">üìä</span><span>Statistique Pro</span></a>
      </nav>
    </details>
    <div class="actions">
      <button id="btnTheme" class="icon-btn" title="Changer de th√®me">üåì</button>
      <button id="btnInfo" class="icon-btn" title="Aide">‚ÑπÔ∏è</button>
    </div>
  </header>

  <main class="container">
    <section class="card" aria-labelledby="section-calc">
      <h2 id="section-calc">Entrez l'√©quation √† r√©soudre :</h2>
      
      <!-- NOUVEAU : S√©lecteur de mode -->
      <div class="mode-selector">
        <button id="btnModeCoeffs" class="btn mode-btn active">Mode Coefficients</button>
        <button id="btnModeText" class="btn mode-btn">Mode √âquation Libre</button>
      </div>

      <!-- Mode Coefficients (Classique) -->
      <div id="modeCoeffsUI" class="equation-container">
        <div class="equation-side">
          <input id="inputA" class="coeff-input" type="text" placeholder="a" aria-label="Coefficient a"> <span>x +</span>
          <input id="inputB" class="coeff-input" type="text" placeholder="b" aria-label="Coefficient b">
        </div>
        <span>=</span>
        <div class="equation-side">
          <input id="inputC" class="coeff-input" type="text" placeholder="c" aria-label="Coefficient c"> <span>x +</span>
          <input id="inputD" class="coeff-input" type="text" placeholder="d" aria-label="Coefficient d">
        </div>
      </div>

      <!-- NOUVEAU : Mode Texte Libre -->
      <div id="modeTextUI" class="equation-container" hidden>
        <input id="inputFullEq" type="text" placeholder="Ex: 2(x+3) = 14  ou  3x - (4-x) = 10">
      </div>

      <div id="liveEquation"></div>
    </section>

    <section class="card">
      <div class="actions">
        <button id="btnSolve" class="btn primary" disabled>R√©soudre</button>
        <button id="btnClear" class="btn">Effacer</button>
      </div>
      <div id="msg" class="msg" role="status" aria-live="polite"></div>
    </section>

    <section id="resultCard" class="card" hidden>
      <pre id="resultSteps"></pre>
      <div class="actions" style="margin-top:10px; gap: 8px;">
        <button id="btnCopy" class="btn">Copier la r√©daction</button>
        <button id="btnNew" class="btn">Nouveau</button>
        <button id="btnExportPDF" class="btn">Exporter en PDF</button>
      </div>
    </section>
  </main>

  <dialog id="dlgHelp">
    <h3>Aide ‚Ä¢ √âquation Pro</h3>
    <p>Cet outil propose deux modes :</p>
    <ul>
      <li><strong>Mode Coefficients :</strong> Pour les √©quations d√©j√† simplifi√©es de la forme <em>ax + b = cx + d</em>.</li>
      <li><strong>Mode √âquation Libre :</strong> Pour √©crire l'√©quation telle quelle (ex: <code>2(x+3) = 14</code>). L'outil d√©veloppera et simplifiera automatiquement.</li>
    </ul>
    <div class="dialog-actions">
      <button id="btnHelpClose" class="btn">Fermer</button>
    </div>
  </dialog>

  <script>
    (function () {
      'use strict';
      
      const LS_THEME = 'equation_1deg_theme_v3';
      const el = {};
      let currentMode = 'coeffs'; // 'coeffs' ou 'text'

      function byId(id) { return document.getElementById(id); }

      function setupElements() {
          const ids = ['inputA', 'inputB', 'inputC', 'inputD', 'liveEquation', 'btnSolve', 
                       'btnClear', 'btnCopy', 'msg', 'resultCard', 'resultSteps', 'btnTheme',
                       'btnNew', 'btnExportPDF', 'btnInfo', 'dlgHelp', 'btnHelpClose',
                       'btnModeCoeffs', 'btnModeText', 'modeCoeffsUI', 'modeTextUI', 'inputFullEq'];
          ids.forEach(id => el[id] = byId(id));
      }

      const format = {
          num: n => n.toLocaleString('fr-FR', {maximumFractionDigits: 4}),
          parenthesis: n => n < 0 ? `(${format.num(n)})` : format.num(n),
          term: (coeff, variable = '') => {
              if (coeff === 0 && variable) return '';
              if (coeff === 0 && !variable) return '0';
              if (Math.abs(coeff) === 1 && variable) return coeff > 0 ? variable : `-${variable}`;
              return `${format.num(coeff)}${variable}`;
          },
          op: (n, isX = false) => {
              const sign = n < 0 ? '-' : '+';
              let val = format.num(Math.abs(n));
              if (isX && Math.abs(n) === 1) val = '';
              return ` ${sign} ${val}${isX ? 'x' : ''}`;
          },
          parenthesisTerm: (coeff, variable = '') => {
              const termStr = format.term(coeff, variable);
              return coeff < 0 ? `(${termStr})` : termStr;
          }
      };

      // --- NOUVEAU : Logique de parsing ---

      // Classe utilitaire pour simplifier les expressions litt√©rales
      const EquationParser = {
          // Simplifie une expression (ex: "2(x+3)") vers ax+b
          simplifyExpression: function(expr) {
              let logs = [];
              let cleanExpr = expr.replace(/\s+/g, '').replace(/,/g, '.');

              // Etape 1 : D√©veloppement des parenth√®ses
              // Tant qu'il y a des parenth√®ses
              let loopSafety = 0;
              while (cleanExpr.includes('(') && loopSafety < 10) {
                  loopSafety++;
                  // Regex pour trouver "Facteur(Contenu)"
                  // G√®re : 2(x), -2(x), -(x), +(x), ou juste (x)
                  // Group 1: Pr√©fixe (nombre, signe ou vide)
                  // Group 2: Contenu
                  const match = cleanExpr.match(/([+\-]?\d*(?:\.\d+)?)\s*\(([^()]+)\)/);
                  
                  if (match) {
                      const fullMatch = match[0];
                      let factorStr = match[1];
                      const content = match[2];

                      // D√©terminer le facteur multiplicatif
                      let factor = 1;
                      if (factorStr === '-' || factorStr === '') {
                          factor = (factorStr === '-') ? -1 : 1;
                          // Si c'√©tait juste "(...)" et qu'il y a un chiffre avant qui n'a pas √©t√© captur√© (cas 3x-(...))
                          // Le regex ci-dessus capture le signe s'il est coll√©.
                          // V√©rification contexte : si le facteur est vide mais pr√©c√©d√© d'un chiffre dans la string compl√®te?
                          // Pour simplifier, on assume que la string est bien form√©e par les √©tapes pr√©c√©dentes.
                      } else {
                          if (factorStr === '+') factor = 1;
                          else factor = parseFloat(factorStr);
                      }

                      // Parser le contenu (somme de termes lin√©aires simples ax+b √† ce niveau)
                      // On fait une mini r√©cursion "light" : on somme les x et les nombres dans la parenth√®se
                      const contentParsed = this.sumTerms(content);
                      
                      // Distribution
                      const newA = factor * contentParsed.a;
                      const newB = factor * contentParsed.b;

                      // Reconstruire la string
                      // ex: 2*3x -> 6x, 2*4 -> 8.
                      // On cr√©e une sous-chaine d√©velopp√©e.
                      let expanded = "";
                      if (newA !== 0) expanded += (newA) + "x"; // On garde le signe brut pour l'instant
                      if (newB !== 0 || newA === 0) expanded += (newB >= 0 && expanded ? "+" : "") + newB;
                      
                      // Astuce: remplacer la partie correspondante dans la string originale
                      // Il faut s'assurer que si le r√©sultat est positif et au milieu, on met un +
                      // Si expanded commence par un nombre positif et n'est pas au d√©but de ligne...
                      
                      // Remplacement simple :
                      // On remplace le match par sa valeur d√©velopp√©e.
                      // Attention aux signes concat√©n√©s (ex: 3x + -2x). On nettoiera apr√®s.
                      cleanExpr = cleanExpr.replace(fullMatch, expanded);
                      
                      logs.push(`On d√©veloppe ${fullMatch} en ${expanded}`);
                  }
              }

              // Etape 2 : Somme des termes (R√©duction)
              const finalTerms = this.sumTerms(cleanExpr);
              
              // Construction de l'expression propre pour l'affichage (ex: "2x + 6")
              let finalExprStr = buildExpr(finalTerms.a, finalTerms.b);
              
              return {
                  a: finalTerms.a,
                  b: finalTerms.b,
                  logs: logs,
                  simplifiedStr: finalExprStr
              };
          },

          // Somme tous les termes en x et constants dans une chaine sans parenth√®ses
          sumTerms: function(str) {
              // On normalise les signes pour split
              // Remplace "-" par "+-" sauf au d√©but
              let normalized = str.replace(/([^\w])-/g, '$1+-');
              if (normalized.startsWith('-')) normalized = '0+' + normalized; // Hack pour le split
              
              const parts = normalized.split('+');
              let a = 0; 
              let b = 0;

              parts.forEach(p => {
                  p = p.trim();
                  if (!p) return;
                  if (p.includes('x')) {
                      // C'est un terme en x
                      let valStr = p.replace('x', '');
                      if (valStr === '' || valStr === '+') a += 1;
                      else if (valStr === '-') a -= 1;
                      else a += parseFloat(valStr);
                  } else {
                      // C'est une constante
                      b += parseFloat(p);
                  }
              });
              return { a, b };
          }
      };

      // ------------------------------------

      function parseInput(id) {
          const val = el[id]?.value.trim().replace(',', '.');
          if (val === '' || val ==='-') return NaN;
          const num = parseFloat(val);
          return isFinite(num) ? num : NaN;
      }
      
      function getInputs() {
          if (currentMode === 'coeffs') {
              return {
                  a: parseInput('inputA'), b: parseInput('inputB'),
                  c: parseInput('inputC'), d: parseInput('inputD'),
                  rawExpr: null
              };
          } else {
              // Parsing du mode texte
              const raw = el.inputFullEq.value;
              if (!raw.includes('=')) return { a: NaN, b:NaN, c:NaN, d:NaN }; // Pas d'√©quation valide
              const sides = raw.split('=');
              if (sides.length !== 2) return { a: NaN };

              try {
                  const lhs = EquationParser.simplifyExpression(sides[0]);
                  const rhs = EquationParser.simplifyExpression(sides[1]);
                  
                  return {
                      a: lhs.a, b: lhs.b,
                      c: rhs.a, d: rhs.b,
                      rawExpr: raw,
                      logs: [...lhs.logs, ...rhs.logs],
                      simplifiedLHS: lhs.simplifiedStr,
                      simplifiedRHS: rhs.simplifiedStr
                  };
              } catch(e) {
                  return { a: NaN };
              }
          }
      }

      function buildExpr(coeffX, constTerm, coeffXName = 'a', constTermName = 'b') {
          let parts = [];
          if (!isNaN(coeffX)) {
              if(coeffX !== 0) parts.push(format.term(coeffX, 'x'));
          } else { parts.push(coeffXName + 'x'); }
          
          if (!isNaN(constTerm)) {
              if (constTerm !== 0) {
                  if (parts.length > 0) parts.push(constTerm > 0 ? '+' : '-');
                  else if (constTerm < 0) parts.push('-');
                  parts.push(format.num(Math.abs(constTerm)));
              }
          } else {
              if (parts.length > 0) parts.push('+');
              parts.push(constTermName);
          }
          let expr = parts.length > 0 ? parts.join(' ').replace(/\+ -/g, '-') : '0';
          return expr.replace(/ \+ /g, ' + ').replace(/ - /g, ' - ');
      }

      function updateLiveUI() {
          const v = getInputs();
          // Validation de base : il faut a,b,c,d valides
          const isValid = !isNaN(v.a) && !isNaN(v.b) && !isNaN(v.c) && !isNaN(v.d);
          el.btnSolve.disabled = !isValid;
          
          if (currentMode === 'coeffs') {
             el.liveEquation.textContent = `${buildExpr(v.a, v.b, 'a', 'b')} = ${buildExpr(v.c, v.d, 'c', 'd')}`;
          } else {
             // Mode texte : on affiche l'√©quation pars√©e/interpr√©t√©e
             if (isValid) {
                 el.liveEquation.innerHTML = `<span style="font-size:0.8em; color:var(--text)">Interpr√©t√© : </span> ${buildExpr(v.a, v.b)} = ${buildExpr(v.c, v.d)}`;
             } else {
                 el.liveEquation.textContent = "En attente d'une √©quation valide...";
             }
          }
      }

      function showMsg(message, type = 'info') {
        el.msg.textContent = message;
        el.msg.className = `msg ${type || 'info'}`;
      }

      function solveEquation(v) {
          let { a, b, c, d } = v;
          let steps = [];
          
          // Si on vient du mode texte et qu'il y a eu simplification
          if (v.rawExpr && (v.logs.length > 0 || (buildExpr(a,b) + " = " + buildExpr(c,d)).replace(/\s/g,'') !== v.rawExpr.replace(/\s/g,''))) {
             steps.push(`<span class="step-header">1. Simplification de l'√©quation</span>`);
             steps.push(`√âquation de d√©part : ${v.rawExpr}`);
             
             // Afficher les √©tapes de d√©veloppement
             v.logs.forEach(log => steps.push(`<span class="comment">‚Ä¢ ${log}</span>`));
             
             steps.push(`On obtient la forme simplifi√©e :`);
             steps.push(`${buildExpr(a,b)} = ${buildExpr(c,d)}\n`);
             steps.push(`<span class="step-header">2. R√©solution</span>`);
          } else {
             steps.push(`${buildExpr(a,b)} = ${buildExpr(c,d)}\n`);
          }

          let stepCounter = 1;
          // Ajustement du compteur si on a d√©j√† fait une simplification
          if(v.rawExpr) stepCounter = 1; 

          // --- Logique de r√©solution originale inchang√©e ---
          if (b !== 0) {
              steps.push(`<span class="comment">‚Ä¢ √âtape : On isole les constantes √† droite</span>`);
              const opStr = `<span class="op-highlight">${format.op(-b)}</span>`;
              steps.push(`${buildExpr(a,b)} ${opStr} = ${buildExpr(c,d)} ${opStr}`);
              d -= b;
              b = 0;
              steps.push(`${buildExpr(a,b)} = ${buildExpr(c,d)}\n`);
          }
          
          if (c !== 0) {
              steps.push(`<span class="comment">‚Ä¢ √âtape : On isole les inconnues √† gauche</span>`);
              const opStr = `<span class="op-highlight">${format.op(-c, true)}</span>`;
              steps.push(`${buildExpr(a,b)} ${opStr} = ${buildExpr(c,d)} ${opStr}`);
              a -= c;
              c = 0;
              steps.push(`${buildExpr(a,b)} = ${buildExpr(c,d)}\n`);
          }
          
          if (a !== 0) {
              const x = d / a;
              steps.push(`<span class="comment">‚Ä¢ √âtape : On divise les deux membres par ${format.num(a)}</span>`);
              steps.push(`${format.parenthesisTerm(a,'x')} √∑ ${format.parenthesis(a)} = ${format.parenthesisTerm(d)} √∑ ${format.parenthesis(a)}`);
              steps.push(`x = ${format.num(x)}`);
              steps.push(`\n<strong>Conclusion : la valeur de x est ${format.num(x)}.</strong>`);
          } else { 
              if (d === 0) { 
                  steps.push(`\n<span class="comment">‚Ä¢ L'√©quation 0 = 0 est toujours vraie.</span>`);
                  steps.push(`<strong>Conclusion : Tout nombre r√©el est solution, S = ‚Ñù.</strong>`);
              } else { 
                  steps.push(`\n<span class="comment">‚Ä¢ L'√©quation ${buildExpr(c,d)} = 0 est impossible.</span>`);
                  steps.push(`<strong>Conclusion : Il n'y a aucune solution, S = ‚àÖ.</strong>`);
              }
          }
          return steps.join('\n');
      }

      function handleSolve() {
          el.resultCard.hidden = true;
          try {
              const values = getInputs();
              if (isNaN(values.a)) throw new Error("Entr√©e invalide");
              
              const steps = solveEquation(values);
              el.resultSteps.innerHTML = steps; 
              el.resultCard.hidden = false;
              showMsg('R√©solution termin√©e.', 'success');
          } catch (e) {
              showMsg('Une erreur est survenue. V√©rifiez votre √©quation.', 'error');
              console.error(e);
          }
      }

      function switchMode(mode) {
          currentMode = mode;
          el.resultCard.hidden = true;
          if (mode === 'coeffs') {
              el.modeCoeffsUI.hidden = false;
              el.modeTextUI.hidden = true;
              el.btnModeCoeffs.classList.add('active');
              el.btnModeText.classList.remove('active');
          } else {
              el.modeCoeffsUI.hidden = true;
              el.modeTextUI.hidden = false;
              el.btnModeCoeffs.classList.remove('active');
              el.btnModeText.classList.add('active');
              el.inputFullEq.focus();
          }
          updateLiveUI();
      }

      function setupEventListeners() {
          el.btnSolve.addEventListener('click', handleSolve);
          
          // Listeners pour le mode Coefficients
          ['inputA', 'inputB', 'inputC', 'inputD'].forEach(id => {
              el[id].addEventListener('input', () => { if(currentMode === 'coeffs') { el.resultCard.hidden = true; updateLiveUI(); }});
              el[id].addEventListener('keypress', (e) => { if (e.key === 'Enter' && !el.btnSolve.disabled) { e.preventDefault(); handleSolve(); }});
          });

          // Listener pour le mode Texte
          el.inputFullEq.addEventListener('input', () => { if(currentMode === 'text') { el.resultCard.hidden = true; updateLiveUI(); } });
          el.inputFullEq.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !el.btnSolve.disabled) { e.preventDefault(); handleSolve(); }});

          // Toggle Mode
          el.btnModeCoeffs.addEventListener('click', () => switchMode('coeffs'));
          el.btnModeText.addEventListener('click', () => switchMode('text'));
          
          const clearAction = () => {
              ['inputA', 'inputB', 'inputC', 'inputD', 'inputFullEq'].forEach(id => el[id].value = '');
              el.resultCard.hidden = true;
              showMsg('Champs effac√©s.');
              updateLiveUI();
          };
          el.btnClear.addEventListener('click', clearAction);
          el.btnNew.addEventListener('click', clearAction);

          el.btnCopy.textContent = "Copier la r√©daction";
          el.btnCopy.addEventListener('click', () => {
              if (el.resultCard.hidden) return;
              navigator.clipboard.writeText(el.resultSteps.innerText)
                  .then(() => showMsg('R√©daction copi√©e.', 'success'));
          });

          el.btnExportPDF.addEventListener('click', () => {
              if (el.resultCard.hidden) return;
              try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                
                // Titre adapt√© selon le mode
                let titleStr = "";
                if(currentMode === 'text' && el.inputFullEq.value) titleStr = el.inputFullEq.value;
                else titleStr = el.liveEquation.textContent;

                const title = `R√©solution de: ${titleStr}`;
                const content = el.resultSteps.innerText;

                doc.setFont('Helvetica', 'bold');
                doc.text(title, 10, 15);

                doc.setFont('Courier', 'normal');
                const splitContent = doc.splitTextToSize(content, 180);
                doc.text(splitContent, 10, 25);
                
                doc.save('Equation_Pro_Redaction.pdf');
                showMsg('Export PDF g√©n√©r√©.', 'success');
              } catch (e) {
                showMsg('Erreur lors de la g√©n√©ration du PDF.', 'error');
                console.error(e);
              }
          });

          el.btnTheme.addEventListener('click', () => {
              const newTheme = document.body.classList.contains('theme-dark') ? 'theme-light' : 'theme-dark';
              document.body.className = newTheme;
              localStorage.setItem(LS_THEME, newTheme);
              el.btnTheme.textContent = newTheme === 'theme-dark' ? '‚òÄÔ∏è' : 'üåô';
          });

          el.btnInfo.addEventListener('click', () => el.dlgHelp.showModal());
          el.btnHelpClose.addEventListener('click', () => el.dlgHelp.close());
      }
      
      document.addEventListener('DOMContentLoaded', () => {
          setupElements();
          const savedTheme = localStorage.getItem(LS_THEME) || 'theme-dark';
          document.body.className = savedTheme;
          el.btnTheme.textContent = savedTheme === 'theme-dark' ? '‚òÄÔ∏è' : 'üåô';
          setupEventListeners();
          updateLiveUI();
      });
    })();
  </script>
</body>
</html>
